# -*- coding: utf-8 -*-
"""recommendation-system

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tkm4tck8l_5_HXd-ljtQwCJagPyEFdeg

# Import Library
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib
import matplotlib.pyplot as plt
import missingno as msno

# %matplotlib inline

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import MinMaxScaler
from sklearn.neighbors import NearestNeighbors
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.metrics import calinski_harabasz_score, davies_bouldin_score

"""# Load Dataset"""

gps = pd.read_csv('googleplaystore.csv')
gps.head()

"""# Data Understanding

Eksplorasi dataset menggunakan fungsi info()
"""

gps.info()

"""Cek jumlah baris dan kolom"""

gps.shape

"""Mengubah kolom Content Rating menjadi Content_Rating"""

gps.rename(columns={'Content Rating': 'Content_Rating'}, inplace=True)

"""Cek jumlah entri unik berdasarkan App, Category, Rating, Type, Content_Rating, dan Genres menggunakan fungsi unique()"""

print('Jumlah data pada App:', len(gps.App.unique()))
print('Jumlah data pada Category:', len(gps.Category.unique()))
print('Jumlah data pada Rating:', len(gps.Rating.unique()))
print('Jumlah data pada Type:', len(gps.Type.unique()))
print('Jumlah data pada Content Rating:', len(gps.Content_Rating.unique()))
print('Jumlah data pada Genres:', len(gps.Genres.unique()))

"""Membagi fitur pada dataset menjadi dua bagian, yaitu data kategori dan data numerik"""

categorical_features = ['App', 'Category', 'Type', 'Content_Rating', 'Genres']
numerical_features = ['Rating']

"""Data Category"""

feature = categorical_features[1]
count = gps[feature].value_counts()
percent = 100*gps[feature].value_counts(normalize=True)
df = pd.DataFrame({'Jumlah sampel': count, 'Persentase': percent.round(1)})

print("\nExploration for feature:", feature)
print(df)

"""Data Category dengan visualiasi bar plot"""

plt.figure(figsize=(8, 6))
count.plot(kind='bar', title=str(feature))
plt.show()

"""Data Type"""

feature = categorical_features[2]
count = gps[feature].value_counts()
percent = 100*gps[feature].value_counts(normalize=True)
df = pd.DataFrame({'Jumlah sampel': count, 'Persentase': percent.round(1)})

print("\nExploration for feature:", feature)
print(df)

"""Data Type dengan visualiasi pie"""

plt.figure(figsize=(8, 6))
gps['Type'].value_counts().plot(kind='pie', autopct='%1.1f%%')
plt.title('Type')
plt.ylabel('')
plt.show()

"""Data Content_Rating"""

feature = categorical_features[3]
count = gps[feature].value_counts()
percent = 100*gps[feature].value_counts(normalize=True)
df = pd.DataFrame({'Jumlah sampel': count, 'Persentase': percent.round(1)})

print("\nExploration for feature:", feature)
print(df)

"""Data Content_Ranting dengan visualiasi bar plot"""

plt.figure(figsize=(8, 6))
gps['Content_Rating'].value_counts().plot(kind='bar')
plt.title('Content Rating')
plt.xticks(rotation=45)
plt.show()

"""Data Genres"""

feature = categorical_features[4]
count = gps[feature].value_counts()
percent = 100*gps[feature].value_counts(normalize=True)
df = pd.DataFrame({'Jumlah sampel': count, 'Persentase': percent.round(1)})

print("\nExploration for feature:", feature)
print(df)

"""Data Genres dengan visualisasi bar plot"""

plt.figure(figsize=(8, 6))
gps['Genres'].value_counts().head(10).plot(kind='bar')
plt.title('Genres')
plt.xticks(rotation=45)
plt.show()

"""Data numerik"""

gps.describe()

"""Data Rating dengan visualisasi histogram"""

gps.hist(bins=50)
plt.show()

"""# Data Preparation

Cek outlier dengan boxplot
"""

gps1=gps.select_dtypes(exclude=['object'])
for column in gps1:
        plt.figure()
        sns.boxplot(data=gps1, x=column)

"""Cek unique data untuk melihat keberadaan outlier"""

gps['Rating'].unique()

"""Tampilkan data outlier"""

gps[gps['Rating']>5]

"""Hapus 1 data outlier"""

gps.drop(gps.index[10472], axis=0, inplace=True)

"""Cek data duplikat"""

gps.duplicated().sum()

"""Hapus data duplikat"""

gps.drop_duplicates(inplace=True)
gps.info()

"""Cek nilai yang hilang"""

gps.isnull().sum()

"""Visualisasi nilai yang hilang"""

sorted_null = msno.nullity_sort(gps)
figures = msno.matrix(sorted_null)

"""Membersihkan nilai yang hilang menggunakan fungsi dropna()"""

gps = gps.dropna()
gps.info()

"""Menghapus Last Updated dan Current Ver"""

gps.drop(['Last Updated', 'Current Ver'], inplace=True, axis=1)
gps.head()

"""# Modeling

## Cosine Similarity

Ekstrak fitur Genres dengan TF-IDF Vectorizer
"""

tfid = TfidfVectorizer()

tfid.fit(gps['Genres'])

tfid.get_feature_names_out()

"""Melakukan fit lalu transformasikan ke bentuk matrix"""

tfidf_matrix = tfid.fit_transform(gps['Genres'])

tfidf_matrix.shape

"""Mengubah vektor tf-idf dalam bentuk matriks menggunakan fungsi todense()"""

tfidf_matrix.todense()

"""Melihat matriks tf-idf untuk nama App terhadap Genres"""

pd.DataFrame(tfidf_matrix.todense(), columns=tfid.get_feature_names_out(), index=gps.Genres).sample(22, axis=1).sample(10, axis=0)

"""Cosine Similarity"""

cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""Membuat dataframe dari variabel cosine_sim dengan baris dan kolom"""

cosine_sim_df = pd.DataFrame(cosine_sim, index=gps['App'], columns=gps['App'])
print('Shape:', cosine_sim_df.shape)

"""Melihat similarity matrix"""

cosine_sim_df.sample(5, axis=1).sample(5, axis=0)

"""Membuat sejumlah top-N recommendation App pada pengguna yang diatur dalam parameter k"""

def app_recommendations(app_name, similarity_data=cosine_sim_df, items=gps[['App', 'Genres']], k=5):
    index = similarity_data.loc[:,app_name].to_numpy().argpartition(range(-1, -k, -1))

    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    closest = closest.drop(app_name, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""Mencari rekomendasi yang mirip dengan App"""

gps[gps.App.eq('EF Spelling Bee')]

"""Mendapatkan rekomendasi yang mirip"""

app_recommendations('EF Spelling Bee')

"""Pengujian model menggunakan filter Type"""

tfid = TfidfVectorizer()
tfid.fit(gps['Type'])
tfid.get_feature_names_out()
tfidf_matrix = tfid.fit_transform(gps['Type'])
tfidf_matrix.todense()
cosine_sim = cosine_similarity(tfidf_matrix)

def app_recommendations(app_name, similarity_data=cosine_sim_df, items=gps[['App', 'Type']], k=5):

    index = similarity_data.loc[:,app_name].to_numpy().argpartition(range(-1, -k, -1))

    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    closest = closest.drop(app_name, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

app_recommendations('EF Spelling Bee')

"""Pengujian model menggunakan filter Content_Rating"""

tfid = TfidfVectorizer()
tfid.fit(gps['Content_Rating'])
tfid.get_feature_names_out()
tfidf_matrix = tfid.fit_transform(gps['Content_Rating'])
tfidf_matrix.todense()
cosine_sim = cosine_similarity(tfidf_matrix)

def app_recommendations(app_name, similarity_data=cosine_sim_df, items=gps[['App', 'Content_Rating']], k=5):

    index = similarity_data.loc[:,app_name].to_numpy().argpartition(range(-1, -k, -1))

    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    closest = closest.drop(app_name, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

app_recommendations('EF Spelling Bee')

"""## K-Nearest Neighbor

Menyimpan nama-nama aplikasi pada dataframe baru
"""

app_name = pd.DataFrame({'App':gps['App']})
app_name.head()

"""Menghapus fitur-fitur 'Type', 'Content_Rating', 'Genres', 'Android Ver"""

gps.drop(['Type',	'Content_Rating',	'Genres',	'Android Ver'], inplace=True,axis=1)
gps.head()

"""Menggunakan kolom App sebagai index"""

gps.set_index('App',inplace=True)
gps.head()

"""Melakukan proses encoding dengan fitur get_dummies."""

gps = pd.concat([gps, pd.get_dummies(gps['Category'], prefix='Category')],axis=1)
gps.drop(['Category'], axis=1, inplace=True)
gps.head()

"""Menyesuaikan pada data kolom 'Size', 'Installs', dan 'Price' melakukan replace string dan mengubah tipe data agar bisa di-scaling"""

gps['Size']= gps['Size'].str.replace('M','000')
gps['Size'] = gps['Size'].str.replace('k','')
gps['Size'] = gps['Size'].replace("Varies with device",'0')
gps['Size'] = gps['Size'].astype('float')

for item in gps['Size']:
  if item < 10:
      gps['Size'] = gps['Size'].replace(item, item*1000)

gps['Size'] = gps['Size']/1000

gps['Installs'] = gps['Installs'].str.replace('+', '')
gps['Installs'] = gps['Installs'].str.replace(',', '')
gps['Installs'] = gps['Installs'].astype('int')

gps['Price'] = gps['Price'].str.replace('$', '')
gps['Price'] = gps['Price'].astype('float')

"""Mengubah sebuah kumpulan data menjadi skala mulai dari 0 (min) hingga 1 (max)"""

column_numeric = ['Reviews', 'Installs', 'Rating', 'Size', 'Price']
scaler = MinMaxScaler()
scaled = scaler.fit_transform(gps[column_numeric])

i=0
for column in column_numeric:
    gps[column] = scaled[:,i]
    i += 1

gps.head()

"""Membuat model menggunakan NearestNeighbors menggunakan euclidean"""

model = NearestNeighbors(metric='euclidean')
model.fit(gps)

"""Membuat fungsi rekomendasi dengan menghitung skor distance"""

def RecommendedApps_model(appname:str, recommend_apps:int=5):
  print(f'Apabila pengguna menyukai aplikasi {appname[0]} Berikut ini adalah aplikasi yang juga mungkin akan disukai :')

  distances, neighbors = model.kneighbors(gps.loc[appname],n_neighbors=recommend_apps)
  similar_app = []

  for appname in app_name.loc[neighbors[0][:]].values:
    similar_app.append(appname[0])

  similar_distance = []

  for distance in distances[0]:
    similar_distance.append(f"{round(100-distance, 2)}%")

  return pd.DataFrame(data = {"App Name" : similar_app, "Similiarity Score" : similar_distance})

"""Memberikan rekomendasi terhadap aplikasi yang serupa"""

RecommendedApps_model(app_name.loc[100])

"""# Evaluation

Metrik evaluasi algoritma pengelompokan menggunakan Calinski Harabasz Score
"""

calinski_harabasz_score(gps, app_name)

"""Metrik evaluasi algoritma pengelompokan menggunakan Davies Bouldin Score"""

davies_bouldin_score(gps, app_name)